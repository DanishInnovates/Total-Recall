<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Total Recall ‚Äì Smart Call Recorder</title>
    <style>
        :root {
            --primary-color: #4285f4;
            --secondary-color: #34a853;
            --danger-color: #ea4335;
            --light-color: #f8f9fa;
            --dark-color: #343a40;
            --border-radius: 8px;
            --box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background-color: #f5f5f5;
            color: #333;
            line-height: 1.6;
            padding: 0;
            margin: 0;
            min-height: 100vh;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            background-color: var(--primary-color);
            color: white;
            padding: 15px 0;
            text-align: center;
            margin-bottom: 20px;
            box-shadow: var(--box-shadow);
        }

        h1 {
            font-size: 1.8rem;
            margin-bottom: 5px;
        }

        .subtitle {
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .recorder-container {
            background-color: white;
            border-radius: var(--border-radius);
            padding: 20px;
            margin-bottom: 20px;
            box-shadow: var(--box-shadow);
        }

        .recorder-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        button {
            padding: 10px 20px;
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background-color: var(--primary-color);
            color: white;
        }

        .btn-secondary {
            background-color: var(--secondary-color);
            color: white;
        }

        .btn-danger {
            background-color: var(--danger-color);
            color: white;
        }

        .btn-outline {
            background-color: transparent;
            border: 1px solid var(--primary-color);
            color: var(--primary-color);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        button:hover:not(:disabled) {
            opacity: 0.9;
            transform: translateY(-2px);
        }

        .recording-status {
            text-align: center;
            margin: 15px 0;
            font-weight: bold;
        }

        .recording-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            background-color: var(--danger-color);
            border-radius: 50%;
            margin-right: 8px;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.3; }
            100% { opacity: 1; }
        }

        .timer {
            font-family: monospace;
            font-size: 1.2rem;
        }

        .recordings-list {
            background-color: white;
            border-radius: var(--border-radius);
            padding: 20px;
            box-shadow: var(--box-shadow);
        }

        .search-bar {
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
        }

        .search-bar input {
            flex: 1;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: var(--border-radius);
            font-size: 1rem;
        }

        .recording-item {
            display: flex;
            flex-direction: column;
            border: 1px solid #eee;
            border-radius: var(--border-radius);
            padding: 15px;
            margin-bottom: 15px;
            transition: all 0.3s ease;
        }

        .recording-item:hover {
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .recording-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .recording-title {
            font-weight: bold;
            font-size: 1.1rem;
            flex: 1;
            margin-right: 10px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .recording-date {
            color: #666;
            font-size: 0.8rem;
        }

        .recording-duration {
            background-color: #f0f0f0;
            padding: 3px 8px;
            border-radius: 10px;
            font-size: 0.8rem;
        }

        .recording-actions {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .recording-notes {
            margin-top: 10px;
            color: #555;
            font-size: 0.9rem;
        }

        audio {
            width: 100%;
            margin-top: 10px;
            border-radius: var(--border-radius);
        }

        .no-recordings {
            text-align: center;
            padding: 30px;
            color: #666;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background-color: white;
            padding: 20px;
            border-radius: var(--border-radius);
            width: 90%;
            max-width: 400px;
            box-shadow: var(--box-shadow);
        }

        .modal-title {
            margin-bottom: 15px;
            font-size: 1.2rem;
            font-weight: bold;
        }

        .modal-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 20px;
        }

        .modal-input {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: var(--border-radius);
            margin-bottom: 10px;
        }

        .modal-textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: var(--border-radius);
            min-height: 80px;
            resize: vertical;
        }

        .pin-input {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 20px 0;
        }

        .pin-input input {
            width: 40px;
            height: 50px;
            text-align: center;
            font-size: 1.5rem;
            border: 1px solid #ddd;
            border-radius: 5px;
        }

        .security-container {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid #eee;
        }

        .tab-container {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 1px solid #ddd;
        }

        .tab {
            padding: 10px 20px;
            cursor: pointer;
            border-bottom: 3px solid transparent;
        }

        .tab.active {
            border-bottom: 3px solid var(--primary-color);
            font-weight: bold;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .settings-option {
            margin-bottom: 15px;
        }

        .settings-option label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
        }

        .settings-option select, .settings-option input[type="text"] {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: var(--border-radius);
        }

        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 50px;
            height: 24px;
        }

        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }

        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
            border-radius: 24px;
        }

        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 50%;
        }

        input:checked + .toggle-slider {
            background-color: var(--primary-color);
        }

        input:checked + .toggle-slider:before {
            transform: translateX(26px);
        }

        .toggle-label {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .export-options {
            margin-top: 20px;
        }

        .export-options button {
            margin-top: 10px;
        }

        @media (max-width: 600px) {
            .recorder-controls {
                flex-direction: column;
                align-items: center;
            }

            .recording-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 5px;
            }

            .recording-date {
                margin-top: 5px;
            }

            .recording-actions {
                flex-wrap: wrap;
            }

            .modal-content {
                width: 95%;
            }
        }

        /* Icons using UTF-8 characters */
        .icon {
            font-size: 1.2rem;
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <h1>Total Recall <span class="icon">üéôÔ∏è</span></h1>
            <p class="subtitle">Smart Call Recorder - All your conversations, remembered</p>
        </div>
    </header>

    <div class="container">
        <div class="tab-container">
            <div class="tab active" data-tab="recorder">Recorder</div>
            <div class="tab" data-tab="recordings">Recordings</div>
            <div class="tab" data-tab="settings">Settings</div>
        </div>

        <div id="recorder" class="tab-content active">
            <div class="recorder-container">
                <h2>Record a Call</h2>
                <p>Click start to begin recording from your microphone</p>

                <div class="recording-status">
                    <div id="status-indicator" style="display: none;">
                        <span class="recording-indicator"></span>
                        <span>Recording in progress</span>
                        <span class="timer" id="recording-timer">00:00:00</span>
                    </div>
                    <div id="paused-indicator" style="display: none;">
                        <span>Recording paused</span>
                        <span class="timer" id="paused-timer">00:00:00</span>
                    </div>
                </div>

                <div class="recorder-controls">
                    <button id="start-btn" class="btn-primary">
                        <span class="icon">‚è∫Ô∏è</span> Start Recording
                    </button>
                    <button id="pause-btn" class="btn-outline" disabled>
                        <span class="icon">‚è∏Ô∏è</span> Pause
                    </button>
                    <button id="stop-btn" class="btn-danger" disabled>
                        <span class="icon">‚èπÔ∏è</span> Stop
                    </button>
                </div>
            </div>
        </div>

        <div id="recordings" class="tab-content">
            <div class="recordings-list">
                <h2>Your Recordings</h2>

                <div class="search-bar">
                    <input type="text" id="search-input" placeholder="Search recordings...">
                    <button id="search-btn" class="btn-outline">
                        <span class="icon">üîç</span> Search
                    </button>
                </div>

                <div id="recordings-container">
                    <!-- Recordings will be loaded here -->
                    <div class="no-recordings">
                        <p>No recordings yet. Start recording to see them here.</p>
                    </div>
                </div>
            </div>
        </div>

        <div id="settings" class="tab-content">
            <div class="recorder-container">
                <h2>Settings</h2>

                <div class="settings-option">
                    <label for="audio-format">Audio Format:</label>
                    <select id="audio-format">
                        <option value="webm">WebM (default)</option>
                        <option value="mp3">MP3 (if supported)</option>
                        <option value="wav">WAV (high quality)</option>
                    </select>
                </div>

                <div class="settings-option">
                    <label for="audio-quality">Audio Quality:</label>
                    <select id="audio-quality">
                        <option value="high">High</option>
                        <option value="medium" selected>Medium</option>
                        <option value="low">Low</option>
                    </select>
                </div>

                <div class="security-container">
                    <h3>Security</h3>

                    <div class="settings-option">
                        <div class="toggle-label">
                            <label for="enable-pin">Enable PIN Lock:</label>
                            <label class="toggle-switch">
                                <input type="checkbox" id="enable-pin">
                                <span class="toggle-slider"></span>
                            </label>
                        </div>
                    </div>

                    <div id="pin-settings" style="display: none;">
                        <div class="settings-option">
                            <label>Set PIN (4 digits):</label>
                            <div class="pin-input">
                                <input type="password" maxlength="1" class="pin-digit" data-index="0">
                                <input type="password" maxlength="1" class="pin-digit" data-index="1">
                                <input type="password" maxlength="1" class="pin-digit" data-index="2">
                                <input type="password" maxlength="1" class="pin-digit" data-index="3">
                            </div>
                            <button id="save-pin-btn" class="btn-primary">Save PIN</button>
                        </div>
                    </div>
                </div>

                <div class="export-options">
                    <h3>Data Management</h3>
                    <button id="export-all-btn" class="btn-outline">
                        <span class="icon">üíæ</span> Export All Recordings
                    </button>
                    <button id="delete-all-btn" class="btn-danger">
                        <span class="icon">üóëÔ∏è</span> Delete All Recordings
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Modals -->
    <div id="save-modal" class="modal">
        <div class="modal-content">
            <div class="modal-title">Save Recording</div>
            <input type="text" id="recording-name" class="modal-input" placeholder="Recording name">
            <textarea id="recording-notes" class="modal-textarea" placeholder="Add notes about this recording..."></textarea>
            <div class="modal-actions">
                <button id="cancel-save-btn" class="btn-outline">Cancel</button>
                <button id="confirm-save-btn" class="btn-primary">Save</button>
            </div>
        </div>
    </div>

    <div id="edit-modal" class="modal">
        <div class="modal-content">
            <div class="modal-title">Edit Recording</div>
            <input type="text" id="edit-name" class="modal-input" placeholder="Recording name">
            <textarea id="edit-notes" class="modal-textarea" placeholder="Add notes about this recording..."></textarea>
            <div class="modal-actions">
                <button id="cancel-edit-btn" class="btn-outline">Cancel</button>
                <button id="confirm-edit-btn" class="btn-primary">Save Changes</button>
            </div>
        </div>
    </div>

    <div id="pin-modal" class="modal">
        <div class="modal-content">
            <div class="modal-title">Enter PIN</div>
            <div class="pin-input">
                <input type="password" maxlength="1" class="pin-digit" data-index="0">
                <input type="password" maxlength="1" class="pin-digit" data-index="1">
                <input type="password" maxlength="1" class="pin-digit" data-index="2">
                <input type="password" maxlength="1" class="pin-digit" data-index="3">
            </div>
            <div class="modal-actions">
                <button id="cancel-pin-btn" class="btn-outline">Cancel</button>
                <button id="confirm-pin-btn" class="btn-primary">Unlock</button>
            </div>
        </div>
    </div>

    <div id="confirm-modal" class="modal">
        <div class="modal-content">
            <div class="modal-title" id="confirm-title">Confirm Action</div>
            <p id="confirm-message">Are you sure you want to perform this action?</p>
            <div class="modal-actions">
                <button id="cancel-confirm-btn" class="btn-outline">Cancel</button>
                <button id="proceed-confirm-btn" class="btn-danger">Proceed</button>
            </div>
        </div>
    </div>

    <script>
        // Main App Class
        class TotalRecallApp {
            constructor() {
                // DOM Elements
                this.elements = {
                    startBtn: document.getElementById('start-btn'),
                    pauseBtn: document.getElementById('pause-btn'),
                    stopBtn: document.getElementById('stop-btn'),
                    statusIndicator: document.getElementById('status-indicator'),
                    pausedIndicator: document.getElementById('paused-indicator'),
                    recordingTimer: document.getElementById('recording-timer'),
                    pausedTimer: document.getElementById('paused-timer'),
                    recordingsContainer: document.getElementById('recordings-container'),
                    searchInput: document.getElementById('search-input'),
                    searchBtn: document.getElementById('search-btn'),
                    audioFormat: document.getElementById('audio-format'),
                    audioQuality: document.getElementById('audio-quality'),
                    enablePin: document.getElementById('enable-pin'),
                    pinSettings: document.getElementById('pin-settings'),
                    savePinBtn: document.getElementById('save-pin-btn'),
                    exportAllBtn: document.getElementById('export-all-btn'),
                    deleteAllBtn: document.getElementById('delete-all-btn'),
                    tabs: document.querySelectorAll('.tab'),
                    tabContents: document.querySelectorAll('.tab-content'),

                    // Modals
                    saveModal: document.getElementById('save-modal'),
                    editModal: document.getElementById('edit-modal'),
                    pinModal: document.getElementById('pin-modal'),
                    confirmModal: document.getElementById('confirm-modal'),

                    // Modal buttons
                    cancelSaveBtn: document.getElementById('cancel-save-btn'),
                    confirmSaveBtn: document.getElementById('confirm-save-btn'),
                    cancelEditBtn: document.getElementById('cancel-edit-btn'),
                    confirmEditBtn: document.getElementById('confirm-edit-btn'),
                    cancelPinBtn: document.getElementById('cancel-pin-btn'),
                    confirmPinBtn: document.getElementById('confirm-pin-btn'),
                    cancelConfirmBtn: document.getElementById('cancel-confirm-btn'),
                    proceedConfirmBtn: document.getElementById('proceed-confirm-btn'),

                    // Modal inputs
                    recordingName: document.getElementById('recording-name'),
                    recordingNotes: document.getElementById('recording-notes'),
                    editName: document.getElementById('edit-name'),
                    editNotes: document.getElementById('edit-notes'),
                    confirmTitle: document.getElementById('confirm-title'),
                    confirmMessage: document.getElementById('confirm-message')
                };

                // Audio recording variables
                this.mediaRecorder = null;
                this.audioChunks = [];
                this.isRecording = false;
                this.isPaused = false;
                this.startTime = null;
                this.pauseStartTime = null;
                this.totalPausedTime = 0;
                this.timerInterval = null;
                this.currentRecordingId = null;

                // App state
                this.recordings = [];
                this.pinEnabled = false;
                this.pinCode = null;
                this.locked = false;

                // Initialize the app
                this.init();
            }

            // Initialize the application
            init() {
                // Load saved data
                this.loadData();

                // Set up event listeners
                this.setupEventListeners();

                // Check if we need to show PIN lock
                if (this.pinEnabled && this.locked) {
                    this.showPinModal();
                } else {
                    this.loadRecordings();
                }

                // Update UI based on settings
                this.updateSettingsUI();
            }

            // Set up all event listeners
            setupEventListeners() {
                // Recording controls
                this.elements.startBtn.addEventListener('click', () => this.startRecording());
                this.elements.pauseBtn.addEventListener('click', () => this.togglePause());
                this.elements.stopBtn.addEventListener('click', () => this.stopRecording());

                // Search functionality
                this.elements.searchInput.addEventListener('keyup', (e) => {
                    if (e.key === 'Enter') this.searchRecordings();
                });
                this.elements.searchBtn.addEventListener('click', () => this.searchRecordings());

                // Settings
                this.elements.enablePin.addEventListener('change', () => this.togglePinSetting());
                this.elements.savePinBtn.addEventListener('click', () => this.savePin());

                // Data management
                this.elements.exportAllBtn.addEventListener('click', () => this.exportAllRecordings());
                this.elements.deleteAllBtn.addEventListener('click', () => this.confirmDeleteAll());

                // Tab navigation
                this.elements.tabs.forEach(tab => {
                    tab.addEventListener('click', () => this.switchTab(tab.dataset.tab));
                });

                // Modal buttons
                this.elements.cancelSaveBtn.addEventListener('click', () => this.hideModal('save'));
                this.elements.confirmSaveBtn.addEventListener('click', () => this.saveRecording());
                this.elements.cancelEditBtn.addEventListener('click', () => this.hideModal('edit'));
                this.elements.confirmEditBtn.addEventListener('click', () => this.updateRecording());
                this.elements.cancelPinBtn.addEventListener('click', () => this.hideModal('pin'));
                this.elements.confirmPinBtn.addEventListener('click', () => this.checkPin());
                this.elements.cancelConfirmBtn.addEventListener('click', () => this.hideModal('confirm'));
                this.elements.proceedConfirmBtn.addEventListener('click', () => this.executeConfirmedAction());

                // PIN digit inputs
                document.querySelectorAll('.pin-digit').forEach(input => {
                    input.addEventListener('input', (e) => this.handlePinInput(e));
                    input.addEventListener('keydown', (e) => this.handlePinNavigation(e));
                });
            }

            // Tab navigation
            switchTab(tabId) {
                // Update active tab
                this.elements.tabs.forEach(tab => {
                    tab.classList.toggle('active', tab.dataset.tab === tabId);
                });

                // Show corresponding content
                this.elements.tabContents.forEach(content => {
                    content.classList.toggle('active', content.id === tabId);
                });
            }

            // Start audio recording
            async startRecording() {
                try {
                    // Request microphone access
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });

                    // Determine MIME type based on settings
                    let mimeType = 'audio/webm';
                    const format = this.elements.audioFormat.value;

                    if (format === 'mp3' && MediaRecorder.isTypeSupported('audio/mpeg')) {
                        mimeType = 'audio/mpeg';
                    } else if (format === 'wav' && MediaRecorder.isTypeSupported('audio/wav')) {
                        mimeType = 'audio/wav';
                    }

                    // Set audio quality (bitrate)
                    let audioBitsPerSecond = 128000; // Medium quality default
                    const quality = this.elements.audioQuality.value;

                    if (quality === 'high') {
                        audioBitsPerSecond = 256000;
                    } else if (quality === 'low') {
                        audioBitsPerSecond = 64000;
                    }

                    // Create media recorder
                    this.mediaRecorder = new MediaRecorder(stream, {
                        mimeType,
                        audioBitsPerSecond
                    });

                    // Event handlers
                    this.mediaRecorder.ondataavailable = (event) => {
                        this.audioChunks.push(event.data);
                    };

                    this.mediaRecorder.onstop = () => {
                        this.showSaveModal();
                        stream.getTracks().forEach(track => track.stop());
                    };

                    this.mediaRecorder.onpause = () => {
                        this.pauseStartTime = Date.now();
                        this.isPaused = true;
                        this.updateTimerDisplay();
                    };

                    this.mediaRecorder.onresume = () => {
                        this.totalPausedTime += Date.now() - this.pauseStartTime;
                        this.isPaused = false;
                        this.updateTimerDisplay();
                    };

                    // Start recording
                    this.mediaRecorder.start(100); // Collect data every 100ms
                    this.isRecording = true;
                    this.startTime = Date.now();
                    this.totalPausedTime = 0;
                    this.audioChunks = [];

                    // Start timer
                    this.timerInterval = setInterval(() => this.updateTimerDisplay(), 1000);

                    // Update UI
                    this.elements.startBtn.disabled = true;
                    this.elements.pauseBtn.disabled = false;
                    this.elements.stopBtn.disabled = false;
                    this.elements.statusIndicator.style.display = 'block';
                    this.elements.pausedIndicator.style.display = 'none';

                } catch (error) {
                    console.error('Error starting recording:', error);
                    alert('Could not access microphone. Please ensure you have granted microphone permissions.');
                }
            }

            // Toggle pause/resume recording
            togglePause() {
                if (!this.mediaRecorder) return;

                if (this.isPaused) {
                    this.mediaRecorder.resume();
                } else {
                    this.mediaRecorder.pause();
                }
            }

            // Stop recording
            stopRecording() {
                if (!this.mediaRecorder || !this.isRecording) return;

                this.mediaRecorder.stop();
                this.isRecording = false;

                // Clear timer
                clearInterval(this.timerInterval);

                // Update UI
                this.elements.startBtn.disabled = false;
                this.elements.pauseBtn.disabled = true;
                this.elements.stopBtn.disabled = true;
                this.elements.statusIndicator.style.display = 'none';
                this.elements.pausedIndicator.style.display = 'none';
            }

            // Update the timer display
            updateTimerDisplay() {
                if (!this.startTime) return;

                const currentTime = Date.now();
                let elapsed = currentTime - this.startTime - this.totalPausedTime;

                if (this.isPaused && this.pauseStartTime) {
                    elapsed -= (currentTime - this.pauseStartTime);
                }

                const hours = Math.floor(elapsed / 3600000).toString().padStart(2, '0');
                const minutes = Math.floor((elapsed % 3600000) / 60000).toString().padStart(2, '0');
                const seconds = Math.floor((elapsed % 60000) / 1000).toString().padStart(2, '0');

                const timeString = `${hours}:${minutes}:${seconds}`;

                if (this.isPaused) {
                    this.elements.pausedTimer.textContent = timeString;
                    this.elements.statusIndicator.style.display = 'none';
                    this.elements.pausedIndicator.style.display = 'block';
                } else {
                    this.elements.recordingTimer.textContent = timeString;
                    this.elements.statusIndicator.style.display = 'block';
                    this.elements.pausedIndicator.style.display = 'none';
                }
            }

            // Show the save recording modal
            showSaveModal() {
                // Generate default name with timestamp
                const now = new Date();
                const timestamp = now.toISOString().replace(/[:.]/g, '-').split('T').join('_').slice(0, 19);
                this.elements.recordingName.value = `Recording_${timestamp}`;
                this.elements.recordingNotes.value = '';

                this.showModal('save');
            }

            // Save the recording to storage
            async saveRecording() {
                const name = this.elements.recordingName.value.trim() || 'Untitled Recording';
                const notes = this.elements.recordingNotes.value.trim();

                // Combine audio chunks
                const audioBlob = new Blob(this.audioChunks);
                const audioUrl = URL.createObjectURL(audioBlob);

                // Calculate duration
                const duration = (Date.now() - this.startTime - this.totalPausedTime) / 1000;

                // Create recording object
                const recording = {
                    id: Date.now().toString(),
                    name,
                    notes,
                    audioUrl,
                    blob: audioBlob,
                    date: new Date().toISOString(),
                    duration,
                    format: this.elements.audioFormat.value
                };

                // Add to recordings array
                this.recordings.unshift(recording);

                // Save to storage
                await this.saveData();

                // Hide modal
                this.hideModal('save');

                // Reload recordings list
                this.loadRecordings();

                // Switch to recordings tab
                this.switchTab('recordings');
            }

            // Load recordings from storage and display them
            loadRecordings(filter = '') {
                const container = this.elements.recordingsContainer;

                if (this.recordings.length === 0) {
                    container.innerHTML = '<div class="no-recordings"><p>No recordings yet. Start recording to see them here.</p></div>';
                    return;
                }

                // Filter recordings if search term is provided
                const filteredRecordings = filter 
                    ? this.recordings.filter(rec => 
                        rec.name.toLowerCase().includes(filter.toLowerCase()) || 
                        rec.notes.toLowerCase().includes(filter.toLowerCase()))
                    : this.recordings;

                if (filteredRecordings.length === 0) {
                    container.innerHTML = '<div class="no-recordings"><p>No recordings match your search.</p></div>';
                    return;
                }

                // Generate HTML for each recording
                container.innerHTML = filteredRecordings.map(rec => this.createRecordingElement(rec)).join('');

                // Add event listeners to the new elements
                document.querySelectorAll('.play-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => this.togglePlayback(e));
                });

                document.querySelectorAll('.delete-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => this.confirmDeleteRecording(e));
                });

                document.querySelectorAll('.edit-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => this.showEditModal(e));
                });

                document.querySelectorAll('.download-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => this.downloadRecording(e));
                });
            }

            // Create HTML element for a recording
            createRecordingElement(recording) {
                const date = new Date(recording.date);
                const dateString = date.toLocaleDateString() + ' ' + date.toLocaleTimeString();

                // Format duration
                const hours = Math.floor(recording.duration / 3600).toString().padStart(2, '0');
                const minutes = Math.floor((recording.duration % 3600) / 60).toString().padStart(2, '0');
                const seconds = Math.floor(recording.duration % 60).toString().padStart(2, '0');
                const durationString = recording.duration >= 3600 
                    ? `${hours}:${minutes}:${seconds}`
                    : `${minutes}:${seconds}`;

                return `
                    <div class="recording-item" data-id="${recording.id}">
                        <div class="recording-header">
                            <div class="recording-title">${recording.name}</div>
                            <div class="recording-duration">${durationString}</div>
                        </div>
                        <div class="recording-date">${dateString}</div>
                        ${recording.notes ? `<div class="recording-notes">${recording.notes}</div>` : ''}
                        <audio src="${recording.audioUrl}" controlsList="nodownload" preload="none"></audio>
                        <div class="recording-actions">
                            <button class="play-btn btn-outline">
                                <span class="icon">‚ñ∂Ô∏è</span> Play
                            </button>
                            <button class="download-btn btn-outline">
                                <span class="icon">‚¨áÔ∏è</span> Download
                            </button>
                            <button class="edit-btn btn-outline">
                                <span class="icon">‚úèÔ∏è</span> Edit
                            </button>
                            <button class="delete-btn btn-danger">
                                <span class="icon">üóëÔ∏è</span> Delete
                            </button>
                        </div>
                    </div>
                `;
            }

            // Toggle audio playback
            togglePlayback(event) {
                const recordingItem = event.target.closest('.recording-item');
                if (!recordingItem) return;

                const audio = recordingItem.querySelector('audio');
                const playBtn = recordingItem.querySelector('.play-btn');

                if (audio.paused) {
                    // Pause all other audio elements first
                    document.querySelectorAll('audio').forEach(a => {
                        if (a !== audio && !a.paused) a.pause();
                    });

                    audio.play();
                    playBtn.innerHTML = '<span class="icon">‚è∏Ô∏è</span> Pause';
                } else {
                    audio.pause();
                    playBtn.innerHTML = '<span class="icon">‚ñ∂Ô∏è</span> Play';
                }
            }

            // Show edit modal for a recording
            showEditModal(event) {
                const recordingId = event.target.closest('.recording-item').dataset.id;
                const recording = this.recordings.find(r => r.id === recordingId);

                if (!recording) return;

                this.currentRecordingId = recordingId;
                this.elements.editName.value = recording.name;
                this.elements.editNotes.value = recording.notes || '';

                this.showModal('edit');
            }

            // Update recording metadata
            async updateRecording() {
                const recording = this.recordings.find(r => r.id === this.currentRecordingId);

                if (!recording) {
                    this.hideModal('edit');
                    return;
                }

                recording.name = this.elements.editName.value.trim() || 'Untitled Recording';
                recording.notes = this.elements.editNotes.value.trim();

                // Save changes
                await this.saveData();

                // Reload recordings
                this.loadRecordings(this.elements.searchInput.value.trim());

                // Hide modal
                this.hideModal('edit');
            }

            // Confirm before deleting a recording
            confirmDeleteRecording(event) {
                const recordingId = event.target.closest('.recording-item').dataset.id;
                this.currentRecordingId = recordingId;

                this.showConfirmModal(
                    'Delete Recording',
                    'Are you sure you want to delete this recording? This action cannot be undone.',
                    'deleteRecording'
                );
            }

            // Delete a recording
            async deleteRecording() {
                this.recordings = this.recordings.filter(r => r.id !== this.currentRecordingId);

                // Save changes
                await this.saveData();

                // Reload recordings
                this.loadRecordings(this.elements.searchInput.value.trim());
            }

            // Download a recording
            downloadRecording(event) {
                const recordingId = event.target.closest('.recording-item').dataset.id;
                const recording = this.recordings.find(r => r.id === recordingId);

                if (!recording) return;

                // Determine file extension based on format
                let extension;
                switch (recording.format) {
                    case 'mp3': extension = 'mp3'; break;
                    case 'wav': extension = 'wav'; break;
                    default: extension = 'webm';
                }

                const url = recording.audioUrl;
                const a = document.createElement('a');
                a.href = url;
                a.download = `${recording.name.replace(/[^a-z0-9]/gi, '_')}.${extension}`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
            }

            // Search recordings
            searchRecordings() {
                const searchTerm = this.elements.searchInput.value.trim();
                this.loadRecordings(searchTerm);
            }

            // Toggle PIN lock setting
            togglePinSetting() {
                const enabled = this.elements.enablePin.checked;
                this.elements.pinSettings.style.display = enabled ? 'block' : 'none';

                if (!enabled) {
                    this.pinEnabled = false;
                    this.pinCode = null;
                    this.saveData();
                }
            }

            // Save PIN code
            savePin() {
                const digits = Array.from(document.querySelectorAll('#pin-settings .pin-digit'))
                    .map(input => input.value)
                    .join('');

                if (digits.length !== 4 || !/^\d+$/.test(digits)) {
                    alert('Please enter a valid 4-digit PIN');
                    return;
                }

                this.pinEnabled = true;
                this.pinCode = digits;
                this.locked = false;

                // Save settings
                this.saveData();

                // Update UI
                this.elements.pinSettings.style.display = 'none';
                this.elements.enablePin.checked = true;

                alert('PIN set successfully');
            }

            // Show PIN modal for unlocking
            showPinModal() {
                this.clearPinInputs();
                this.showModal('pin');
            }

            // Check entered PIN
            checkPin() {
                const enteredPin = Array.from(document.querySelectorAll('#pin-modal .pin-digit'))
                    .map(input => input.value)
                    .join('');

                if (enteredPin === this.pinCode) {
                    this.locked = false;
                    this.saveData();
                    this.hideModal('pin');
                    this.loadRecordings();
                } else {
                    alert('Incorrect PIN. Please try again.');
                    this.clearPinInputs();
                }
            }

            // Handle PIN input navigation
            handlePinInput(event) {
                const input = event.target;
                const nextIndex = parseInt(input.dataset.index) + 1;

                if (input.value && nextIndex < 4) {
                    document.querySelector(`.pin-digit[data-index="${nextIndex}"]`).focus();
                }
            }

            // Handle PIN input navigation with keyboard
            handlePinNavigation(event) {
                const input = event.target;
                const currentIndex = parseInt(input.dataset.index);

                if (event.key === 'Backspace' && !input.value && currentIndex > 0) {
                    const prevInput = document.querySelector(`.pin-digit[data-index="${currentIndex - 1}"]`);
                    prevInput.value = '';
                    prevInput.focus();
                } else if (event.key === 'ArrowLeft' && currentIndex > 0) {
                    document.querySelector(`.pin-digit[data-index="${currentIndex - 1}"]`).focus();
                } else if (event.key === 'ArrowRight' && currentIndex < 3) {
                    document.querySelector(`.pin-digit[data-index="${currentIndex + 1}"]`).focus();
                }
            }

            // Clear all PIN inputs
            clearPinInputs() {
                document.querySelectorAll('.pin-digit').forEach(input => {
                    input.value = '';
                });
                document.querySelector('.pin-digit[data-index="0"]').focus();
            }

            // Export all recordings as a ZIP (simulated with multiple downloads)
            async exportAllRecordings() {
                if (this.recordings.length === 0) {
                    alert('No recordings to export');
                    return;
                }

                // In a real implementation, we would use a library like JSZip
                // Since we can't use external libraries, we'll simulate it with multiple downloads

                // Create a timestamp for the export
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').split('T').join('_').slice(0, 19);

                // Create a manifest file
                const manifest = {
                    app: "Total Recall - Smart Call Recorder",
                    version: "1.0",
                    exportDate: new Date().toISOString(),
                    recordings: this.recordings.map(rec => ({
                        id: rec.id,
                        name: rec.name,
                        date: rec.date,
                        duration: rec.duration,
                        notes: rec.notes,
                        format: rec.format
                    }))
                };

                // Create manifest download
                this.downloadTextAsFile(
                    JSON.stringify(manifest, null, 2),
                    `TotalRecall_Export_${timestamp}_manifest.json`,
                    'application/json'
                );

                // Download each recording
                for (const recording of this.recordings) {
                    // Determine file extension based on format
                    let extension;
                    switch (recording.format) {
                        case 'mp3': extension = 'mp3'; break;
                        case 'wav': extension = 'wav'; break;
                        default: extension = 'webm';
                    }

                    const url = recording.audioUrl;
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `TotalRecall_Export_${timestamp}/${recording.name.replace(/[^a-z0-9]/gi, '_')}.${extension}`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);

                    // Add a small delay between downloads to avoid browser restrictions
                    await new Promise(resolve => setTimeout(resolve, 200));
                }

                alert(`Export initiated. ${this.recordings.length + 1} files will be downloaded.`);
            }

            // Confirm before deleting all recordings
            confirmDeleteAll() {
                if (this.recordings.length === 0) {
                    alert('No recordings to delete');
                    return;
                }

                this.showConfirmModal(
                    'Delete All Recordings',
                    'Are you sure you want to delete ALL recordings? This action cannot be undone.',
                    'deleteAllRecordings'
                );
            }

            // Delete all recordings
            async deleteAllRecordings() {
                this.recordings = [];
                await this.saveData();
                this.loadRecordings();
                alert('All recordings have been deleted');
            }

            // Show confirm modal for destructive actions
            showConfirmModal(title, message, action) {
                this.elements.confirmTitle.textContent = title;
                this.elements.confirmMessage.textContent = message;
                this.currentAction = action;
                this.showModal('confirm');
            }

            // Execute the confirmed action
            executeConfirmedAction() {
                switch (this.currentAction) {
                    case 'deleteRecording':
                        this.deleteRecording();
                        break;
                    case 'deleteAllRecordings':
                        this.deleteAllRecordings();
                        break;
                }

                this.hideModal('confirm');
            }

            // Show a modal
            showModal(type) {
                if (this.pinEnabled && this.locked && type !== 'pin') {
                    this.showPinModal();
                    return;
                }

                const modal = this.elements[`${type}Modal`];
                if (modal) {
                    modal.style.display = 'flex';

                    // Focus first input if available
                    const input = modal.querySelector('input');
                    if (input) input.focus();
                }
            }

            // Hide a modal
            hideModal(type) {
                const modal = this.elements[`${type}Modal`];
                if (modal) modal.style.display = 'none';
            }

            // Download text as a file
            downloadTextAsFile(text, filename, mimeType) {
                const blob = new Blob([text], { type: mimeType });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            // Update UI based on settings
            updateSettingsUI() {
                this.elements.enablePin.checked = this.pinEnabled;
                this.elements.pinSettings.style.display = this.pinEnabled ? 'block' : 'none';

                if (this.pinEnabled) {
                    // Pre-fill PIN inputs with saved PIN (for display only, shows as dots)
                    const pinDigits = this.pinCode.split('');
                    document.querySelectorAll('#pin-settings .pin-digit').forEach((input, index) => {
                        input.value = pinDigits[index] || '';
                    });
                }
            }

            // Load data from localStorage
            loadData() {
                const savedData = localStorage.getItem('totalRecallData');

                if (savedData) {
                    try {
                        const data = JSON.parse(savedData);
                        this.recordings = data.recordings || [];
                        this.pinEnabled = data.pinEnabled || false;
                        this.pinCode = data.pinCode || null;
                        this.locked = data.locked || false;
                    } catch (e) {
                        console.error('Error loading saved data:', e);
                    }
                }
            }

            // Save data to localStorage
            async saveData() {
                const data = {
                    recordings: this.recordings,
                    pinEnabled: this.pinEnabled,
                    pinCode: this.pinCode,
                    locked: this.locked
                };

                try {
                    localStorage.setItem('totalRecallData', JSON.stringify(data));
                } catch (e) {
                    console.error('Error saving data:', e);
                    alert('Error saving data. Your browser storage might be full.');
                }
            }
        }

        // Initialize the app when the page loads
        document.addEventListener('DOMContentLoaded', () => {
            const app = new TotalRecallApp();

            // Make app available globally for debugging if needed
            window.totalRecallApp = app;
        });
    </script>
</body>
</html>